import * as Control$dSemigroupoid from "./Control.Semigroupoid.js";
import * as Data$dSemiring from "./Data.Semiring.js";
import * as Data$dTuple from "./Data.Tuple.js";
import * as Data$dUnit from "./Data.Unit.js";
const State = x => x;
const unState = v => k$p => s => v((_3, _4) => k$p(_3)(_4), s);
const runState = s => k => k((_2, _3) => Data$dTuple.$Tuple(_2, _3), s);
const mkState = k => (k$p, s) => k(_3 => _4 => k$p(_3, _4))(s);
const put = s => (k$p, s_1) => k$p(s, Data$dUnit.unit);
const functorState = {map: f => k => (k$p, s) => k((_4, _5) => k$p(_4, f(_5)), s)};
let monadState;
let bindState;
let applyState;
let applicativeState;
monadState = {Applicative0: () => applicativeState, Bind1: () => bindState};
bindState = {bind: k1 => k2 => (k$p, s) => k1((_4, _5) => k2(_5)((_6, _7) => k$p(_6, _7), _4), s), Apply0: () => applyState};
applyState = {apply: f => a => (k$p, s) => f((_4, _5) => a((_6, _7) => applicativeState.pure(_5(_7))((_8, _9) => k$p(_8, _9), _6), _4), s), Functor0: () => functorState};
applicativeState = {pure: a => (k$p, s) => k$p(s, a), Apply0: () => applyState};
const $$get = (k$p, s) => k$p(s, s);
const test4 = (k$p, s) => k$p(s + 2 | 0, Data$dUnit.unit);
export {State, applicativeState, applyState, bindState, functorState, $$get as get, mkState, monadState, put, runState, test4, unState};